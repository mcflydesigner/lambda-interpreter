// File generated by the BNF Converter (bnfc 2.9.4).

package hardtyped;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class VisitSkel
{
  public class ProgramVisitor<R,A> implements hardtyped.Absyn.Program.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Progr p, A arg)
    { /* Code for Progr goes here */
      p.stm_.accept(new StmVisitor<R,A>(), arg);
      return null;
    }
  }
  public class StmVisitor<R,A> implements hardtyped.Absyn.Stm.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.ImportAs p, A arg)
    { /* Code for ImportAs goes here */
      p.identifier_1.accept(new IdentifierVisitor<R,A>(), arg);
      p.identifier_2.accept(new IdentifierVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.ImportPlain p, A arg)
    { /* Code for ImportPlain goes here */
      p.identifier_.accept(new IdentifierVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.If p, A arg)
    { /* Code for If goes here */
      p.ifstart_.accept(new IfStartVisitor<R,A>(), arg);
      p.else_.accept(new ElseVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Let p, A arg)
    { /* Code for Let goes here */
      p.identifier_.accept(new IdentifierVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      p.expression_1.accept(new ExpressionVisitor<R,A>(), arg);
      p.expression_2.accept(new ExpressionVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Letrec p, A arg)
    { /* Code for Letrec goes here */
      p.identifier_.accept(new IdentifierVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class IfStartVisitor<R,A> implements hardtyped.Absyn.IfStart.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.IfStart1 p, A arg)
    { /* Code for IfStart1 goes here */
      p.expression_.accept(new ExpressionVisitor<R,A>(), arg);
      p.body_.accept(new BodyVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ElseVisitor<R,A> implements hardtyped.Absyn.Else.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Else1 p, A arg)
    { /* Code for Else1 goes here */
      p.body_.accept(new BodyVisitor<R,A>(), arg);
      return null;
    }
  }
  public class BodyVisitor<R,A> implements hardtyped.Absyn.Body.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Body1 p, A arg)
    { /* Code for Body1 goes here */
      p.expression_.accept(new ExpressionVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ExpressionVisitor<R,A> implements hardtyped.Absyn.Expression.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Expression1 p, A arg)
    { /* Code for Expression1 goes here */
      p.conjunction_.accept(new ConjunctionVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Expression2 p, A arg)
    { /* Code for Expression2 goes here */
      p.conjunction_.accept(new ConjunctionVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ConjunctionVisitor<R,A> implements hardtyped.Absyn.Conjunction.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Conjunction1 p, A arg)
    { /* Code for Conjunction1 goes here */
      p.relation_1.accept(new RelationVisitor<R,A>(), arg);
      p.relation_2.accept(new RelationVisitor<R,A>(), arg);
      return null;
    }
  }
  public class RelationVisitor<R,A> implements hardtyped.Absyn.Relation.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Relation1 p, A arg)
    { /* Code for Relation1 goes here */
      p.factor_.accept(new FactorVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Relation2 p, A arg)
    { /* Code for Relation2 goes here */
      p.factor_1.accept(new FactorVisitor<R,A>(), arg);
      p.operand_.accept(new OperandVisitor<R,A>(), arg);
      p.factor_2.accept(new FactorVisitor<R,A>(), arg);
      return null;
    }
  }
  public class FactorVisitor<R,A> implements hardtyped.Absyn.Factor.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Factor1 p, A arg)
    { /* Code for Factor1 goes here */
      p.term_.accept(new TermVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Factor2 p, A arg)
    { /* Code for Factor2 goes here */
      p.term_1.accept(new TermVisitor<R,A>(), arg);
      p.plusminus_.accept(new PlusMinusVisitor<R,A>(), arg);
      p.term_2.accept(new TermVisitor<R,A>(), arg);
      return null;
    }
  }
  public class TermVisitor<R,A> implements hardtyped.Absyn.Term.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Term1 p, A arg)
    { /* Code for Term1 goes here */
      p.unary_.accept(new UnaryVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Term2 p, A arg)
    { /* Code for Term2 goes here */
      p.unary_1.accept(new UnaryVisitor<R,A>(), arg);
      p.multdiv_.accept(new MultDivVisitor<R,A>(), arg);
      p.unary_2.accept(new UnaryVisitor<R,A>(), arg);
      return null;
    }
  }
  public class UnaryVisitor<R,A> implements hardtyped.Absyn.Unary.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Unary1 p, A arg)
    { /* Code for Unary1 goes here */
      p.expression_.accept(new ExpressionVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Unary2 p, A arg)
    { /* Code for Unary2 goes here */
      p.literal_.accept(new LiteralVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.Unary3 p, A arg)
    { /* Code for Unary3 goes here */
      p.unaryprefix_.accept(new UnaryPrefixVisitor<R,A>(), arg);
      p.identifier_.accept(new IdentifierVisitor<R,A>(), arg);
      p.ascription_.accept(new AscriptionVisitor<R,A>(), arg);
      return null;
    }
  }
  public class AscriptionVisitor<R,A> implements hardtyped.Absyn.Ascription.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Ascription1 p, A arg)
    { /* Code for Ascription1 goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class LiteralVisitor<R,A> implements hardtyped.Absyn.Literal.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.ArrayLiteral p, A arg)
    { /* Code for ArrayLiteral goes here */
      p.expression_.accept(new ExpressionVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.FunctionLiteral p, A arg)
    { /* Code for FunctionLiteral goes here */
      p.functionparameters_.accept(new FunctionParametersVisitor<R,A>(), arg);
      p.functionbody_.accept(new FunctionBodyVisitor<R,A>(), arg);
      return null;
    }
    public R visit(hardtyped.Absyn.RecordLiteral p, A arg)
    { /* Code for RecordLiteral goes here */
      p.recordelement_.accept(new RecordElementVisitor<R,A>(), arg);
      return null;
    }
  }
  public class RecordElementVisitor<R,A> implements hardtyped.Absyn.RecordElement.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.RecordElement1 p, A arg)
    { /* Code for RecordElement1 goes here */
      p.identifier_.accept(new IdentifierVisitor<R,A>(), arg);
      p.expression_.accept(new ExpressionVisitor<R,A>(), arg);
      return null;
    }
  }
  public class FunctionParametersVisitor<R,A> implements hardtyped.Absyn.FunctionParameters.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.FunctionParameters1 p, A arg)
    { /* Code for FunctionParameters1 goes here */
      p.identifier_.accept(new IdentifierVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class FunctionBodyVisitor<R,A> implements hardtyped.Absyn.FunctionBody.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.FunctionBody1 p, A arg)
    { /* Code for FunctionBody1 goes here */
      p.body_.accept(new BodyVisitor<R,A>(), arg);
      return null;
    }
  }
  public class IdentifierVisitor<R,A> implements hardtyped.Absyn.Identifier.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Identifier1 p, A arg)
    { /* Code for Identifier1 goes here */
      //p.string_;
      return null;
    }
  }
  public class TypeVisitor<R,A> implements hardtyped.Absyn.Type.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Int p, A arg)
    { /* Code for Int goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.Real p, A arg)
    { /* Code for Real goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.String p, A arg)
    { /* Code for String goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.Boolean p, A arg)
    { /* Code for Boolean goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.Unit p, A arg)
    { /* Code for Unit goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.FunctionTypeIndicator p, A arg)
    { /* Code for FunctionTypeIndicator goes here */
      p.type_1.accept(new TypeVisitor<R,A>(), arg);
      p.type_2.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class OperandVisitor<R,A> implements hardtyped.Absyn.Operand.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Less p, A arg)
    { /* Code for Less goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.LessEql p, A arg)
    { /* Code for LessEql goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.More p, A arg)
    { /* Code for More goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.MoreEql p, A arg)
    { /* Code for MoreEql goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.Eql p, A arg)
    { /* Code for Eql goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.NotEql p, A arg)
    { /* Code for NotEql goes here */
      return null;
    }
  }
  public class PlusMinusVisitor<R,A> implements hardtyped.Absyn.PlusMinus.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Plus p, A arg)
    { /* Code for Plus goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.Minus p, A arg)
    { /* Code for Minus goes here */
      return null;
    }
  }
  public class MultDivVisitor<R,A> implements hardtyped.Absyn.MultDiv.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.Mult p, A arg)
    { /* Code for Mult goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.Div p, A arg)
    { /* Code for Div goes here */
      return null;
    }
  }
  public class UnaryPrefixVisitor<R,A> implements hardtyped.Absyn.UnaryPrefix.Visitor<R,A>
  {
    public R visit(hardtyped.Absyn.PlusPfx p, A arg)
    { /* Code for PlusPfx goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.MinusPfx p, A arg)
    { /* Code for MinusPfx goes here */
      return null;
    }
    public R visit(hardtyped.Absyn.NotPfx p, A arg)
    { /* Code for NotPfx goes here */
      return null;
    }
  }
}
