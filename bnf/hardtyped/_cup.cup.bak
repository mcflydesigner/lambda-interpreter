// -*- Java -*- File generated by the BNF Converter (bnfc 2.9.4).

// Parser definition for use with Java Cup
package hardtyped;

action code {:
public java_cup.runtime.ComplexSymbolFactory.Location getLeftLocation(
    java_cup.runtime.ComplexSymbolFactory.Location ... locations) {
  for (java_cup.runtime.ComplexSymbolFactory.Location l : locations) {
    if (l != null) {
      return l;
    }
  }
  return null;
}
:}
parser code {:
  public hardtyped.Absyn.Program pProgram() throws Exception
  {
    java_cup.runtime.Symbol res = parse();
    return (hardtyped.Absyn.Program) res.value;
  }

public void syntax_error(java_cup.runtime.Symbol cur_token)
{
  report_error("Syntax Error, trying to recover and continue parse...", cur_token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception
{
  throw new Exception("Unrecoverable Syntax Error");
}

:}

nonterminal hardtyped.Absyn.Program Program;
nonterminal hardtyped.Absyn.ListImport ListImport;
nonterminal hardtyped.Absyn.ListExpr ListExpr;
nonterminal hardtyped.Absyn.Import Import;
nonterminal hardtyped.Absyn.Expr Expr;
nonterminal hardtyped.Absyn.ListIfCase ListIfCase;
nonterminal hardtyped.Absyn.IfCase IfCase;
nonterminal hardtyped.Absyn.ElseCase ElseCase;
nonterminal hardtyped.Absyn.LetHead LetHead;
nonterminal hardtyped.Absyn.Expr Expr2;
nonterminal hardtyped.Absyn.Op Op;
nonterminal hardtyped.Absyn.PlusMinus PlusMinus;
nonterminal hardtyped.Absyn.MultDiv MultDiv;
nonterminal hardtyped.Absyn.Expr Expr3;
nonterminal hardtyped.Absyn.UnaryDef UnaryDef;
nonterminal hardtyped.Absyn.ListFuncParameter ListFuncParameter;
nonterminal hardtyped.Absyn.FuncParameter FuncParameter;
nonterminal hardtyped.Absyn.FuncBody FuncBody;
nonterminal hardtyped.Absyn.Literal Literal;
nonterminal hardtyped.Absyn.Expr Expr1;
nonterminal hardtyped.Absyn.Type Type;

terminal _SYMB_0;    //   ;
terminal _SYMB_1;    //   -|
terminal _SYMB_2;    //   |
terminal _SYMB_3;    //   :
terminal _SYMB_4;    //   |:
terminal _SYMB_5;    //   =
terminal _SYMB_6;    //   <
terminal _SYMB_7;    //   <=
terminal _SYMB_8;    //   >
terminal _SYMB_9;    //   >=
terminal _SYMB_10;    //   ==
terminal _SYMB_11;    //   !=
terminal _SYMB_12;    //   +
terminal _SYMB_13;    //   -
terminal _SYMB_14;    //   *
terminal _SYMB_15;    //   /
terminal _SYMB_16;    //   /\
terminal _SYMB_17;    //   .
terminal _SYMB_18;    //   {
terminal _SYMB_19;    //   }
terminal _SYMB_20;    //   (
terminal _SYMB_21;    //   )
terminal _SYMB_22;    //   ->
terminal _SYMB_23;    //   Boolean
terminal _SYMB_24;    //   Int
terminal _SYMB_25;    //   Real
terminal _SYMB_26;    //   Str
terminal _SYMB_27;    //   Unit
terminal _SYMB_28;    //   and
terminal _SYMB_29;    //   as
terminal _SYMB_30;    //   false
terminal _SYMB_31;    //   in
terminal _SYMB_32;    //   let
terminal _SYMB_33;    //   letrec
terminal _SYMB_34;    //   or
terminal _SYMB_35;    //   true
terminal _SYMB_36;    //   unit

terminal String _STRING_;

terminal Integer _INTEGER_;
terminal Double _DOUBLE_;
terminal String _IDENT_;



start with Program;


Program ::= ListImport:p_1 ListExpr:p_2  {: RESULT = new hardtyped.Absyn.Progr(p_1,p_2); :}
;
ListImport ::=  /* empty */  {: RESULT = new hardtyped.Absyn.ListImport(); :}
  | ListImport:p_1 Import:p_2  {: RESULT = p_1; p_1.addLast(p_2); :}
;
ListExpr ::=  /* empty */  {: RESULT = new hardtyped.Absyn.ListExpr(); :}
  | Expr:p_1  {: RESULT = new hardtyped.Absyn.ListExpr(); RESULT.addLast(p_1); :}
  | Expr:p_1 _SYMB_0:p_2 ListExpr:p_3  {: RESULT = p_3; p_3.addFirst(p_1); :}
;
Import ::= _SYMB_1:p_1 _STRING_:p_2 _SYMB_29:p_3 _IDENT_:p_4  {: RESULT = new hardtyped.Absyn.ImportAs(p_2,p_4); :}
  | _SYMB_1:p_1 _STRING_:p_2  {: RESULT = new hardtyped.Absyn.ImportPlain(p_2); :}
;
Expr ::= ListIfCase:p_1 ElseCase:p_2  {: RESULT = new hardtyped.Absyn.If(p_1,p_2); :}
  | LetHead:p_1  {: RESULT = new hardtyped.Absyn.Let1(p_1); :}
  | LetHead:p_1 _SYMB_31:p_2 Expr:p_3  {: RESULT = new hardtyped.Absyn.Let2(p_1,p_3); :}
  | _SYMB_16:p_1 ListFuncParameter:p_2 FuncBody:p_3  {: RESULT = new hardtyped.Absyn.Function(p_2,p_3); :}
  | Expr1:p_1  {: RESULT = p_1; :}
;
ListIfCase ::= IfCase:p_1  {: RESULT = new hardtyped.Absyn.ListIfCase(); RESULT.addLast(p_1); :}
  | IfCase:p_1 ListIfCase:p_2  {: RESULT = p_2; p_2.addFirst(p_1); :}
;
IfCase ::= _SYMB_2:p_1 Expr:p_2 _SYMB_3:p_3 Expr:p_4  {: RESULT = new hardtyped.Absyn.IfCase1(p_2,p_4); :}
;
ElseCase ::= _SYMB_4:p_1 Expr:p_2  {: RESULT = new hardtyped.Absyn.ElseCase1(p_2); :}
;
LetHead ::= _SYMB_32:p_1 _IDENT_:p_2 _SYMB_5:p_3 Expr:p_4  {: RESULT = new hardtyped.Absyn.LetHeadPlain(p_2,p_4); :}
  | _SYMB_33:p_1 _IDENT_:p_2 _SYMB_5:p_3 Expr:p_4  {: RESULT = new hardtyped.Absyn.LetrecHead(p_2,p_4); :}
;
Expr2 ::= Expr:p_1 _SYMB_34:p_2 Expr:p_3  {: RESULT = new hardtyped.Absyn.Disjunction(p_1,p_3); :}
  | Expr:p_1 _SYMB_28:p_2 Expr:p_3  {: RESULT = new hardtyped.Absyn.Conjunction(p_1,p_3); :}
  | Expr:p_1 Op:p_2 Expr:p_3  {: RESULT = new hardtyped.Absyn.Relation(p_1,p_2,p_3); :}
  | Expr:p_1 PlusMinus:p_2 Expr:p_3  {: RESULT = new hardtyped.Absyn.Factor(p_1,p_2,p_3); :}
  | Expr:p_1 MultDiv:p_2 Expr:p_3  {: RESULT = new hardtyped.Absyn.Term(p_1,p_2,p_3); :}
  | Expr3:p_1  {: RESULT = p_1; :}
;
Op ::= _SYMB_6:p_1  {: RESULT = new hardtyped.Absyn.Op1(); :}
  | _SYMB_7:p_1  {: RESULT = new hardtyped.Absyn.Op2(); :}
  | _SYMB_8:p_1  {: RESULT = new hardtyped.Absyn.Op3(); :}
  | _SYMB_9:p_1  {: RESULT = new hardtyped.Absyn.Op4(); :}
  | _SYMB_10:p_1  {: RESULT = new hardtyped.Absyn.Op5(); :}
  | _SYMB_11:p_1  {: RESULT = new hardtyped.Absyn.Op6(); :}
;
PlusMinus ::= _SYMB_12:p_1  {: RESULT = new hardtyped.Absyn.PlusMinus1(); :}
  | _SYMB_13:p_1  {: RESULT = new hardtyped.Absyn.PlusMinus2(); :}
;
MultDiv ::= _SYMB_14:p_1  {: RESULT = new hardtyped.Absyn.MultDiv1(); :}
  | _SYMB_15:p_1  {: RESULT = new hardtyped.Absyn.MultDiv2(); :}
;
Expr3 ::= UnaryDef:p_1  {: RESULT = new hardtyped.Absyn.Unary(p_1); :}
  | _SYMB_20:p_1 Expr:p_2 _SYMB_21:p_3  {: RESULT = p_2; :}
;
UnaryDef ::= Literal:p_1  {: RESULT = new hardtyped.Absyn.UnaryDefLiteral(p_1); :}
  | _IDENT_:p_1  {: RESULT = new hardtyped.Absyn.UnaryDefIdent(p_1); :}
;
ListFuncParameter ::=  /* empty */  {: RESULT = new hardtyped.Absyn.ListFuncParameter(); :}
  | ListFuncParameter:p_1 FuncParameter:p_2 _SYMB_17:p_3  {: RESULT = p_1; p_1.addLast(p_2); :}
;
FuncParameter ::= _IDENT_:p_1 _SYMB_3:p_2 Type:p_3  {: RESULT = new hardtyped.Absyn.FuncParameter1(p_1,p_3); :}
;
FuncBody ::= _SYMB_18:p_1 ListExpr:p_2 _SYMB_19:p_3  {: RESULT = new hardtyped.Absyn.FuncBody1(p_2); :}
;
Literal ::= _INTEGER_:p_1  {: RESULT = new hardtyped.Absyn.IntegerLiteral(p_1); :}
  | _SYMB_36:p_1  {: RESULT = new hardtyped.Absyn.UnitLiteral(); :}
  | _SYMB_35:p_1  {: RESULT = new hardtyped.Absyn.BooleanLiteral_true(); :}
  | _SYMB_30:p_1  {: RESULT = new hardtyped.Absyn.BooleanLiteral_false(); :}
  | _STRING_:p_1  {: RESULT = new hardtyped.Absyn.StringLiteral(p_1); :}
  | _DOUBLE_:p_1  {: RESULT = new hardtyped.Absyn.RealLiteral(p_1); :}
;
Expr1 ::= Expr2:p_1  {: RESULT = p_1; :}
;
Type ::= _SYMB_24:p_1  {: RESULT = new hardtyped.Absyn.Int(); :}
  | _SYMB_25:p_1  {: RESULT = new hardtyped.Absyn.Real(); :}
  | _SYMB_26:p_1  {: RESULT = new hardtyped.Absyn.Str(); :}
  | _SYMB_23:p_1  {: RESULT = new hardtyped.Absyn.Boolean(); :}
  | _SYMB_27:p_1  {: RESULT = new hardtyped.Absyn.Unit(); :}
  | Type:p_1 _SYMB_22:p_2 Type:p_3  {: RESULT = new hardtyped.Absyn.FunctionType(p_1,p_3); :}
;

