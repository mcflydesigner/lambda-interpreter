// -*- Java -*- File generated by the BNF Converter (bnfc 2.9.4).

// Parser definition for use with Java Cup
package hardtyped;

action code {:
public java_cup.runtime.ComplexSymbolFactory.Location getLeftLocation(
    java_cup.runtime.ComplexSymbolFactory.Location ... locations) {
  for (java_cup.runtime.ComplexSymbolFactory.Location l : locations) {
    if (l != null) {
      return l;
    }
  }
  return null;
}
:}
parser code {:
  public hardtyped.Absyn.Program pProgram() throws Exception
  {
    java_cup.runtime.Symbol res = parse();
    return (hardtyped.Absyn.Program) res.value;
  }

public void syntax_error(java_cup.runtime.Symbol cur_token)
{
  report_error("Syntax Error, trying to recover and continue parse...", cur_token);
}

public void unrecovered_syntax_error(java_cup.runtime.Symbol cur_token) throws java.lang.Exception
{
  throw new Exception("Unrecoverable Syntax Error");
}

:}

nonterminal hardtyped.Absyn.Program Program;
nonterminal hardtyped.Absyn.Stm Stm;
nonterminal hardtyped.Absyn.IfStart IfStart;
nonterminal hardtyped.Absyn.Else Else;
nonterminal hardtyped.Absyn.Body Body;
nonterminal hardtyped.Absyn.Expression Expression;
nonterminal hardtyped.Absyn.Conjunction Conjunction;
nonterminal hardtyped.Absyn.Relation Relation;
nonterminal hardtyped.Absyn.Factor Factor;
nonterminal hardtyped.Absyn.Term Term;
nonterminal hardtyped.Absyn.Unary Unary;
nonterminal hardtyped.Absyn.Ascription Ascription;
nonterminal hardtyped.Absyn.Literal Literal;
nonterminal hardtyped.Absyn.RecordElement RecordElement;
nonterminal hardtyped.Absyn.FunctionParameters FunctionParameters;
nonterminal hardtyped.Absyn.FunctionBody FunctionBody;
nonterminal hardtyped.Absyn.Identifier Identifier;
nonterminal hardtyped.Absyn.Type Type;
nonterminal hardtyped.Absyn.Operand Operand;
nonterminal hardtyped.Absyn.PlusMinus PlusMinus;
nonterminal hardtyped.Absyn.MultDiv MultDiv;
nonterminal hardtyped.Absyn.UnaryPrefix UnaryPrefix;

terminal _SYMB_0;    //   -|
terminal _SYMB_1;    //   |
terminal _SYMB_2;    //   :
terminal _SYMB_3;    //   |:
terminal _SYMB_4;    //   =
terminal _SYMB_5;    //   {
terminal _SYMB_6;    //   }
terminal _SYMB_7;    //   [
terminal _SYMB_8;    //   ]
terminal _SYMB_9;    //   /\
terminal _SYMB_10;    //   .
terminal _SYMB_11;    //   ->
terminal _SYMB_12;    //   <
terminal _SYMB_13;    //   <=
terminal _SYMB_14;    //   >
terminal _SYMB_15;    //   >=
terminal _SYMB_16;    //   /=
terminal _SYMB_17;    //   +
terminal _SYMB_18;    //   -
terminal _SYMB_19;    //   *
terminal _SYMB_20;    //   /
terminal _SYMB_21;    //   Boolean
terminal _SYMB_22;    //   Int
terminal _SYMB_23;    //   Real
terminal _SYMB_24;    //   Str
terminal _SYMB_25;    //   Unit
terminal _SYMB_26;    //   as
terminal _SYMB_27;    //   in
terminal _SYMB_28;    //   let
terminal _SYMB_29;    //   letrec
terminal _SYMB_30;    //   not







terminal String Int;
terminal String Real;
terminal String Str;
terminal String Unit;


start with Program;


Program ::= Stm:p_1  {: RESULT = new hardtyped.Absyn.Progr(p_1); :}
;
Stm ::= _SYMB_0:p_1 Identifier:p_2 _SYMB_26:p_3 Identifier:p_4  {: RESULT = new hardtyped.Absyn.ImportAs(p_2,p_4); :}
  | _SYMB_0:p_1 Identifier:p_2  {: RESULT = new hardtyped.Absyn.ImportPlain(p_2); :}
  | IfStart:p_1 Else:p_2  {: RESULT = new hardtyped.Absyn.If(p_1,p_2); :}
  | _SYMB_28:p_1 Identifier:p_2 _SYMB_2:p_3 Type:p_4 _SYMB_4:p_5 Expression:p_6 _SYMB_27:p_7 Expression:p_8  {: RESULT = new hardtyped.Absyn.Let(p_2,p_4,p_6,p_8); :}
  | _SYMB_29:p_1 Identifier:p_2 _SYMB_2:p_3 Type:p_4  {: RESULT = new hardtyped.Absyn.Letrec(p_2,p_4); :}
;
IfStart ::= _SYMB_1:p_1 Expression:p_2 _SYMB_2:p_3 Body:p_4  {: RESULT = new hardtyped.Absyn.IfStart1(p_2,p_4); :}
;
Else ::= _SYMB_3:p_1 Body:p_2  {: RESULT = new hardtyped.Absyn.Else1(p_2); :}
;
Body ::= Expression:p_1  {: RESULT = new hardtyped.Absyn.Body1(p_1); :}
;
Expression ::= Conjunction:p_1  {: RESULT = new hardtyped.Absyn.Expression1(p_1); :}
  | _SYMB_5:p_1 Conjunction:p_2 _SYMB_6:p_3  {: RESULT = new hardtyped.Absyn.Expression2(p_2); :}
;
Conjunction ::= Relation:p_1 Relation:p_2  {: RESULT = new hardtyped.Absyn.Conjunction1(p_1,p_2); :}
;
Relation ::= Factor:p_1  {: RESULT = new hardtyped.Absyn.Relation1(p_1); :}
  | Factor:p_1 Operand:p_2 Factor:p_3  {: RESULT = new hardtyped.Absyn.Relation2(p_1,p_2,p_3); :}
;
Factor ::= Term:p_1  {: RESULT = new hardtyped.Absyn.Factor1(p_1); :}
  | Term:p_1 PlusMinus:p_2 Term:p_3  {: RESULT = new hardtyped.Absyn.Factor2(p_1,p_2,p_3); :}
;
Term ::= Unary:p_1  {: RESULT = new hardtyped.Absyn.Term1(p_1); :}
  | Unary:p_1 MultDiv:p_2 Unary:p_3  {: RESULT = new hardtyped.Absyn.Term2(p_1,p_2,p_3); :}
;
Unary ::= Expression:p_1  {: RESULT = new hardtyped.Absyn.Unary1(p_1); :}
  | Literal:p_1  {: RESULT = new hardtyped.Absyn.Unary2(p_1); :}
  | UnaryPrefix:p_1 Identifier:p_2 Ascription:p_3  {: RESULT = new hardtyped.Absyn.Unary3(p_1,p_2,p_3); :}
;
Ascription ::= _SYMB_26:p_1 Type:p_2  {: RESULT = new hardtyped.Absyn.Ascription1(p_2); :}
;
Literal ::= _SYMB_7:p_1 Expression:p_2 _SYMB_8:p_3  {: RESULT = new hardtyped.Absyn.ArrayLiteral(p_2); :}
  | _SYMB_9:p_1 FunctionParameters:p_2 _SYMB_10:p_3 FunctionBody:p_4  {: RESULT = new hardtyped.Absyn.FunctionLiteral(p_2,p_4); :}
  | _SYMB_5:p_1 RecordElement:p_2 _SYMB_6:p_3  {: RESULT = new hardtyped.Absyn.RecordLiteral(p_2); :}
;
RecordElement ::= Identifier:p_1 _SYMB_4:p_2 Expression:p_3  {: RESULT = new hardtyped.Absyn.RecordElement1(p_1,p_3); :}
;
FunctionParameters ::= Identifier:p_1 _SYMB_2:p_2 Type:p_3  {: RESULT = new hardtyped.Absyn.FunctionParameters1(p_1,p_3); :}
;
FunctionBody ::= Body:p_1  {: RESULT = new hardtyped.Absyn.FunctionBody1(p_1); :}
;
Identifier ::= Str:p_1  {: RESULT = new hardtyped.Absyn.Identifier1(p_1); :}
;
Type ::= _SYMB_22:p_1  {: RESULT = new hardtyped.Absyn.Int(); :}
  | _SYMB_23:p_1  {: RESULT = new hardtyped.Absyn.Real(); :}
  | _SYMB_24:p_1  {: RESULT = new hardtyped.Absyn.Str(); :}
  | _SYMB_21:p_1  {: RESULT = new hardtyped.Absyn.Boolean(); :}
  | _SYMB_25:p_1  {: RESULT = new hardtyped.Absyn.Unit(); :}
  | Type:p_1 _SYMB_11:p_2 Type:p_3  {: RESULT = new hardtyped.Absyn.FunctionTypeIndicator(p_1,p_3); :}
;
Operand ::= _SYMB_12:p_1  {: RESULT = new hardtyped.Absyn.Less(); :}
  | _SYMB_13:p_1  {: RESULT = new hardtyped.Absyn.LessEql(); :}
  | _SYMB_14:p_1  {: RESULT = new hardtyped.Absyn.More(); :}
  | _SYMB_15:p_1  {: RESULT = new hardtyped.Absyn.MoreEql(); :}
  | _SYMB_4:p_1  {: RESULT = new hardtyped.Absyn.Eql(); :}
  | _SYMB_16:p_1  {: RESULT = new hardtyped.Absyn.NotEql(); :}
;
PlusMinus ::= _SYMB_17:p_1  {: RESULT = new hardtyped.Absyn.Plus(); :}
  | _SYMB_18:p_1  {: RESULT = new hardtyped.Absyn.Minus(); :}
;
MultDiv ::= _SYMB_19:p_1  {: RESULT = new hardtyped.Absyn.Mult(); :}
  | _SYMB_20:p_1  {: RESULT = new hardtyped.Absyn.Div(); :}
;
UnaryPrefix ::= _SYMB_17:p_1  {: RESULT = new hardtyped.Absyn.PlusPfx(); :}
  | _SYMB_18:p_1  {: RESULT = new hardtyped.Absyn.MinusPfx(); :}
  | _SYMB_30:p_1  {: RESULT = new hardtyped.Absyn.NotPfx(); :}
;

